{
  "hash": "5b8c8b295f3ad01cca5265c634f69829",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bayesian Nonparametric Models in NIMBLE, Part 2: Nonparametric Random Effects\"\ndate: \"2018-12-06\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\ncategories: [\"tutorial\", \"R\"]\nexecute:\n  freeze: auto\n---\n\n# Bayesian nonparametrics in NIMBLE: Nonparametric random effects\n\n## Overview\n\nNIMBLE is a hierarchical modeling package that uses nearly the same language for model specification as the popular MCMC packages WinBUGS, OpenBUGS and JAGS, while making the modeling language extensible — you can add distributions and functions — and also allowing customization of the algorithms used to estimate the parameters of the model.\n\nRecently, we added support for Markov chain Monte Carlo (MCMC) inference for Bayesian nonparametric (BNP) mixture models to NIMBLE. In particular, starting with version 0.6-11, NIMBLE provides functionality for fitting models involving Dirichlet process priors using either the Chinese Restaurant Process (CRP) or a truncated stick-breaking (SB) representation of the Dirichlet process prior.\n\nWe will illustrate NIMBLE’s BNP capabilities using two examples. In a previous post, we showed how to use nonparametric mixture models with different kernels for density estimation. In this post, we will take a parametric generalized linear mixed model and show how to switch to a nonparametric representation of the random effects that avoids the assumption of normally-distributed random effects.\n\nFor more detailed information on NIMBLE and Bayesian nonparametrics in NIMBLE, see the [NIMBLE User Manual](https://r-nimble.org/documentation).\n\n## Parametric meta analysis of Avandia myocardial infarctions (MIs)\n\nWe will illustrate the use of nonparametric mixture models for modeling random effects distributions in the context of a meta-analysis of the side effects of a formerly very popular drug for diabetes called Avandia. The data we analyze played a role in raising serious questions about the safety of this drug. The question is whether Avandia use increases the risk of myocardial infarction (heart attack). There are 48 studies (the 49th study in the data file is different in some ways and excluded here), each with treatment and control arms.\n    \n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- read.csv('../nimbleExamples/avandia.csv')\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  trial nAvandia avandiaMI nControl controlMI\n1     1      357         2      176         0\n2     2      391         2      207         1\n3     3      774         1      185         1\n4     4      213         0      109         1\n5     5      232         1      116         0\n6     6       43         0       47         1\n```\n\n\n:::\n\n```{.r .cell-code}\ndat <- dat[-49, ]\n```\n:::\n\n\n### Model formulation\n\nWe begin with a standard generalized linear mixed model (GLMM)-based meta analysis. The vectors $n$ and $x$ contain the total number of patients in the control and the number of patients suffering from myocardial infarctions in the control group of each study, respectively. Similarly, the vectors $m$ and $y$ contain similar information for patients receiving the drug Avandia. The model takes the form\n\n$$x_{i} \\mid \\theta, \\gamma_i \\sim \\text{Bin} \\left(n_i, \\frac{\\exp\\left\\{ \\gamma_i \\right\\}}{1 + \\exp\\left\\{ \\gamma_i \\right\\}} \\right) , \\quad\\quad y_{i} \\mid \\theta, \\gamma_i \\sim \\text{Bin} \\left(m_i, \\frac{\\exp\\left\\{ \\theta + \\gamma_i \\right\\}}{1 + \\exp\\left\\{ \\theta + \\gamma_i \\right\\}} \\right)$$\n\nwhere the random effects, $\\gamma_i$, follow a common normal distribution, $\\gamma_i \\sim \\text{N}(0, \\tau^2)$, and the $\\theta$ and $\\tau^2$ are given reasonably non-informative priors. The parameter $\\theta$ quantifies the difference in risk between the control and treatment arms, while the $\\gamma_i$ quantify study-specific variation.\n\nThis model can be specified in NIMBLE using the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nimble)\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- dat$controlMI\nn <- dat$nControl\ny <- dat$avandiaMI\nm <- dat$nAvandia\n\nnStudies <- nrow(dat)\ndata <- list(x = x, y = y)\nconstants = list(n = n, m = m, nStudies = nStudies)\n\ncodeParam <- nimbleCode({\n    for(i in 1:nStudies) {\n        y[i] ~ dbin(size = m[i], prob = q[i]) # avandia MIs\n        x[i] ~ dbin(size = n[i], prob = p[i]) # control MIs\n        q[i] <- expit(theta + gamma[i])       # Avandia log-odds\n        p[i] <- expit(gamma[i])               # control log-odds\n        gamma[i] ~ dnorm(mu, var = tau2)      # study effects\n    }\n    theta ~ dflat()        # effect of Avandia\n    # random effects hyperparameters\n    mu ~ dnorm(0, 10)\n    tau2 ~ dinvgamma(2, 1)\n})\n```\n:::\n\n\n### Running the MCMC\n\nLet’s run a basic MCMC.\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(9)\ninits = list(theta = 0, mu = 0, tau2 = 1, gamma = rnorm(nStudies))\n\nsamples <- nimbleMCMC(code = codeParam, data = data, inits = inits,\n                      constants = constants, monitors = c(\"mu\", \"tau2\", \"theta\", \"gamma\"),\n                      thin = 10, niter = 22000, nburnin = 2000, nchains = 1, setSeed = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model calculations\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n```{.r .cell-code}\npar(mfrow = c(1, 4), cex = 0.9, mgp = c(1.8,.7,0), mai = c(.5,.5,.4,.1))\nts.plot(samples[ , 'theta'], xlab = 'iteration', ylab = expression(theta))\nhist(samples[ , 'theta'], xlab = expression(theta), main = 'effect of Avandia')\n\ngammaCols <- grep('gamma', colnames(samples))\ngammaMn <- colMeans(samples[ , gammaCols])\nhist(gammaMn, xlab = 'posterior means', main = 'random effects distribution')\nhist(samples[1000, gammaCols], xlab = 'single draw',\n                   main = 'random effects distribution')\n```\n\n::: {.cell-output-display}\n![](bayesian-nonparametric-models-in-nimble-part-2-nonparametric-random-effects_files/figure-html/unnamed-chunk-4-1.png){width=1152}\n:::\n:::\n\nThe results suggests there is an overall difference in risk between the control and treatment arms. But what about the normality assumption? Are our conclusions robust to that assumption? Perhaps the random effects distribution are skewed. (And recall that the estimates above of the random effects are generated under the normality assumption, which pushes the estimated effects to look more normal…)\n\n## DP-based random effects modeling for meta analysis\n\n### Model formulation\n\nNow, we use a nonparametric distribution for the $\\gamma_i$s. More specifically, we assume that each $\\gamma_i$ is generated from a location-scale mixture of normal distributions:\n\n$$\\gamma_i \\mid \\mu_i, \\tau_i^2 \\sim \\text{N}(\\mu_i, \\tau_i^2), \\quad\\quad (\\mu_i, \\tau_i^2) \\mid G \\sim G, \\quad\\quad G \\sim \\text{DP}(\\alpha, H),$$\n\nwhere $H$ is a normal-inverse-gamma distribution.\n\nThis specification induces clustering among the random effects. As in the case of density estimation problems, the DP prior allows the data to determine the number of components, from as few as one component (i.e., simplifying to the parametric model), to as many as $n$ components, i.e., one component for each observation. This allows the distribution of the random effects to be multimodal if the data supports such behavior, greatly increasing its flexibility. This model can be specified in NIMBLE using the following code:\n    \n\n::: {.cell}\n\n```{.r .cell-code}\ncodeBNP <- nimbleCode({\n    for(i in 1:nStudies) {\n        y[i] ~ dbin(size = m[i], prob = q[i])   # avandia MIs\n        x[i] ~ dbin(size = n[i], prob = p[i])   # control MIs\n        q[i] <- expit(theta + gamma[i])         # Avandia log-odds\n        p[i] <- expit(gamma[i])                 # control log-odds\n        gamma[i] ~ dnorm(mu[i], var = tau2[i])  # random effects from mixture dist.\n        mu[i] <- muTilde[xi[i]]                 # mean for random effect from cluster xi[i]\n        tau2[i] <- tau2Tilde[xi[i]]             # var for random effect from cluster xi[i]\n    }\n    # mixture component parameters drawn from base measures\n    for(i in 1:nStudies) {\n        muTilde[i] ~ dnorm(mu0, var = var0)\n        tau2Tilde[i] ~ dinvgamma(a0, b0)\n    }\n    # CRP for clustering studies to mixture components\n    xi[1:nStudies] ~ dCRP(alpha, size = nStudies)\n    # hyperparameters\n    alpha ~ dgamma(1, 1)\n    mu0 ~ dnorm(0, 10)\n    var0 ~ dinvgamma(2, 1)\n    a0 ~ dinvgamma(2, 1)\n    b0 ~ dinvgamma(2, 1)\n    theta ~ dflat()          # effect of Avandia\n})\n```\n:::\n\n\n### Running the MCMC\n\nThe following code compiles the model and runs a collapsed Gibbs sampler for the model\n    \n\n::: {.cell}\n\n```{.r .cell-code}\ninits <- list(gamma = rnorm(nStudies), xi = sample(1:2, nStudies, replace = TRUE),\n              alpha = 1, mu0 = 0, var0 = 1, a0 = 1, b0 = 1, theta = 0,\n              muTilde = rnorm(nStudies), tau2Tilde = rep(1, nStudies))\n\nsamplesBNP <- nimbleMCMC(code = codeBNP, data = data, inits = inits,\n               constants = constants,\n               monitors = c(\"theta\", \"gamma\", \"alpha\", \"xi\", \"mu0\", \"var0\", \"a0\", \"b0\"),\n               thin = 10, niter = 22000, nburnin = 2000, nchains = 1, setSeed = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model calculations\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n```{.r .cell-code}\ngammaCols <- grep('gamma', colnames(samplesBNP))\ngammaMn <- colMeans(samplesBNP[ , gammaCols])\nxiCols <- grep('xi', colnames(samplesBNP))\n\npar(mfrow = c(1,5), cex = 0.9, mgp = c(1.8,.7,0), mai = c(.5,.5,.4,.1))\nts.plot(samplesBNP[ , 'theta'], xlab = 'iteration', ylab = expression(theta),\n   main = expression(paste('traceplot for ', theta)))\nhist(samplesBNP[ , 'theta'], xlab = expression(theta), main = 'effect of Avandia')\nhist(gammaMn, xlab = 'posterior means',\n              main = \"random effects distrib'n\")\nhist(samplesBNP[1000, gammaCols], xlab = 'single draw',\n                   main = \"random effects distrib'n\")\n\n# How many mixture components are inferred?\nxiRes <- samplesBNP[ , xiCols]\nnGrps <- apply(xiRes, 1, function(x) length(unique(x)))\nts.plot(nGrps, xlab = 'iteration', ylab = 'number of components',\n   main = 'number of components')\n```\n\n::: {.cell-output-display}\n![](bayesian-nonparametric-models-in-nimble-part-2-nonparametric-random-effects_files/figure-html/unnamed-chunk-6-1.png){width=1152}\n:::\n:::\n\n\nThe primary inference seems robust to the original parametric assumption. This is probably driven by the fact that there is not much evidence of lack of normality in the random effects distribution (as evidenced by the fact that the posterior distribution of the number of mixture components places a large amount of probability on exactly one component).\n\n## More information and future development\n\nPlease see our [User Manual](https://r-nimble.org/documentation) for more details.\n\nWe’re in the midst of improvements to the existing BNP functionality as well as adding additional Bayesian nonparametric models, such as hierarchical Dirichlet processes and Pitman-Yor processes, so please add yourself to our [announcement](https://groups.google.com/forum/#!forum/nimble-announce) or [user support/discussion](https://groups.google.com/forum/#!forum/nimble-users) Google groups.",
    "supporting": [
      "bayesian-nonparametric-models-in-nimble-part-2-nonparametric-random-effects_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}