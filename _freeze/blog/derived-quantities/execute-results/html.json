{
  "hash": "80fc027e68e71df3d87e1000612e4981",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Using derived quantities in NIMBLE's MCMC system\"\nauthor: \"NIMBLE Development Team\"\ndate: \"2026-01-27\"\ncategories: ['announcement','R','tutorial']\nexecute:\n  freeze: true\n---\n\nNIMBLE is a system for building and sharing analysis methods for statistical models, especially for hierarchical models and computationally-intensive methods (such as MCMC, Laplace approximation, and sequential Monte Carlo).\n\nAs of version 1.4.0, NIMBLE allows one to specify \"derived quantities\" to calculate or record additional quantities of interest during an MCMC. Potential derived quantities include:\n\n - posterior means, \n - posterior variances, \n - log-probabilities (log-density values) for single or (summed) groups of nodes,\n - posterior predictive samples for predictive nodes, and\n - arbitrary calculations by providing a user-defined nimbleFunction that follows the required specification.\n\nBy using derived quantities, users can avoid adding additional nodes to the model itself and can potentially reduce how much is stored during an MCMC run and saved as output from the run, thereby reducing memory and disk use.\n\nWe'll give a brief example of saving log-probability (log-posterior-density) values summed over a set of nodes in a simple Poisson random effects model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nimble)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npumpCode <- nimbleCode({ \n    for(i in 1:N) {\n        theta[i] ~ dgamma(alpha, beta)\n        lambda[i] <- theta[i]*t[i]\n        x[i] ~ dpois(lambda[i])\n    }\n    alpha ~ dexp(1.0)\n    beta ~ dgamma(0.1, 1.0)\n})\n\npumpConsts <- list(N = 10,\n                   t = c(94.3, 15.7, 62.9, 126, 5.24,\n                         31.4, 1.05, 1.05, 2.1, 10.5))\npumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))\npumpInits <- list(alpha = 1, beta = 1,\n                  theta = rep(0.1, pumpConsts$N))\npumpModel <- nimbleModel(pumpCode, pumpConsts, pumpData, pumpInits)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n:::\n\n\nNow we add the `logProb` derived quantity, specified directly as an argument to `configureMCMC`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconf <- configureMCMC(pumpModel, logProb = c('alpha', 'beta'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n===== Monitors =====\nthin = 1: alpha, beta\n===== Samplers =====\nRW sampler (1)\n  - alpha\nconjugate sampler (11)\n  - beta\n  - theta[]  (10 elements)\n===== DerivedQ =====\n- logProb (1)\n```\n\n\n:::\n\n```{.r .cell-code}\nconf$printDerivedQuantities()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] derived quantity: logProb,  execution interval: thin,  nodes: c(alpha, beta)\n```\n\n\n:::\n:::\n\n\nWhen we run the MCMC, we see the derived quantities are saved as an element of the output list, in addition to the usual posterior samples of the parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc <- buildMCMC(conf)\n\ncPumpModel <- compileNimble(pumpModel)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n```{.r .cell-code}\ncmcmc <- compileNimble(mcmc)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n```{.r .cell-code}\nrunMCMC(cmcmc, niter = 100, thin = 20)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$samples\n         alpha      beta\n[1,] 0.7434957 0.8437510\n[2,] 0.5046057 0.8152505\n[3,] 0.5201513 1.3765454\n[4,] 1.1023278 2.2564913\n[5,] 1.4316249 2.1598157\n\n$derived\n$derived$logProb\n          alpha      beta\n[1,] -0.7434957 -2.943556\n[2,] -0.5046057 -2.884129\n[3,] -0.5201513 -3.916877\n[4,] -1.1023278 -5.241634\n[5,] -1.4316249 -5.105549\n```\n\n\n:::\n:::\n\n\nWe could also have added the `logProb` derived quantity to an existing MCMC configuration argument (and also illustrating that one can modify the interval at which recording is done):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconf <- configureMCMC(pumpModel)\nconf$addDerivedQuantity('logProb', nodes = c('alpha', 'beta'), interval = 10)\n```\n:::\n\n\nThe operation of every derived quantity function is governed by an `interval` parameter. Each derived quantity function is executed at the end of every `interval` MCMC iterations (and only for iterations after the burnin period). The default value for `interval` is given by the `thin` interval of the MCMC. For example, if `interval = 1` (regardless of the `thin` value), then that derived quantity function will execute at the end of every MCMC sampling iteration. \n\nNote that user-defined derived quantity nimbleFunctions provide a general way for a user to intervene at the end of an MCMC iteration and do something. This would often be recording a value (to be returned at the end of the MCMC) or updating some summary statistic, but the derived quantities system doesn't require this, giving users flexibility.\n\nMore details can be found in the [NIMBLE User Manual](https://r-nimble.org/manual/cha-mcmc.html#sec:derived-quantities) and via `help(derived)`.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}