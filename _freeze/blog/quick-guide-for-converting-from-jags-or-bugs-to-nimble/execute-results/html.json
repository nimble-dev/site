{
  "hash": "a1c2baebd1767e65d6a32d32a2d1fe26",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Quick guide for converting from JAGS or BUGS to NIMBLE\"\ndate: \"2018-05-30\"\nauthor: \"NIMBLE Development Team\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\ncategories: [\"tutorial\", \"R\"] \nexecute:\n  freeze: auto\n---\n\nConverting to NIMBLE from JAGS, OpenBUGS or WinBUGS  \n  \n\n#  Converting to NIMBLE from JAGS, OpenBUGS or WinBUGS \n\nNIMBLE is a hierarchical modeling package that uses nearly the same modeling language as the popular MCMC packages WinBUGS, OpenBUGS and JAGS. NIMBLE makes the modeling language extensible — you can add distributions and functions — and also allows customization of MCMC or other algorithms that use models. Here is a quick summary of steps to convert existing code from WinBUGS, OpenBUGS or JAGS to NIMBLE. For more information, see examples on [r-nimble.org](http://r-nimble.org/) or the [NIMBLE User Manual](https://r-nimble.org/manuals/NimbleUserManual.pdf). \n\n##  Main steps for converting existing code \n\nThese steps assume you are familiar with running WinBUGS, OpenBUGS or JAGS through an R package such as `R2WinBUGS`, `R2jags`, `rjags`, or `jagsUI`. \n\n  1. Wrap your model code in `nimbleCode({})`, directly in R.\n     * This replaces the step of writing or generating a separate file containing the model code.\n     * Alternatively, you can read standard JAGS- and BUGS-formatted code and data files using  \n`readBUGSmodel`.\n  2. Provide information about missing or empty indices \n     * Example: If `x` is a matrix, you must write at least `x[,]` to show it has two dimensions.\n     * If other declarations make the size of `x` clear, `x[,]` will work in some circumstances.\n     * If not, either provide index ranges (e.g. `x[1:n, 1:m]`) or use the `dimensions` argument to `nimbleModel` to provide the sizes in each dimension.\n  3. Choose how you want to run MCMC. \n     * Use `nimbleMCMC()` as the just-do-it way to run an MCMC. This will take all steps to  \nset up and run an MCMC using NIMBLE’s default configuration.\n     * To use NIMBLE’s full flexibility: build the model, configure and build the MCMC, and compile both the model and MCMC. Then run the MCMC via `runMCMC` or by calling the `run` function of the compiled MCMC. See the NIMBLE User Manual to learn more about what you can do.\n\nSee below for a list of some more nitty-gritty additional steps you may need to consider for some models. \n\n##  Example: An animal abundance model \n\nThis example is adapted from Chapter 6, Section 6.4 of [Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS. Volume I: Prelude and Static Models](https://www.elsevier.com/books/applied-hierarchical-modeling-in-ecology-analysis-of-distribution-abundance-and-species-richness-in-r-and-bugs/kery/978-0-12-801378-6) by Marc Kéry and J. Andrew Royle (2015, Academic Press). The [book’s web site](https://www.mbr-pwrc.usgs.gov/pubanalysis/keryroylebook/) provides code for its examples. \n\n###  Original code \n\nThe original model code looks like this: \n    \n\n::: {.cell}\n\n```{.r .cell-code}\ncat(file = \"model2.txt\",\"\nmodel {\n# Priors\nfor(k in 1:3){                # Loop over 3 levels of hab or time factors\n   alpha0[k] ~ dunif(-10, 10) # Detection intercepts\n   alpha1[k] ~ dunif(-10, 10) # Detection slopes\n   beta0[k] ~ dunif(-10, 10)  # Abundance intercepts\n   beta1[k] ~ dunif(-10, 10)  # Abundance slopes\n}\n\n# Likelihood\n# Ecological model for true abundance\nfor (i in 1:M){\n   N[i] ~ dpois(lambda[i])\n   log(lambda[i]) <- beta0[hab[i]] + beta1[hab[i]] * vegHt[i]\n   # Some intermediate derived quantities\n   critical[i] <- step(2-N[i])# yields 1 whenever N is 2 or less\n   z[i] <- step(N[i]-0.5)     # Indicator for occupied site\n   # Observation model for replicated counts\n   for (j in 1:J){\n      C[i,j] ~ dbin(p[i,j], N[i])\n      logit(p[i,j]) <- alpha0[j] + alpha1[j] * wind[i,j]\n   }\n}\n\n# Derived quantities\nNocc <- sum(z[])         # Number of occupied sites among sample of M\nNtotal <- sum(N[])       # Total population size at M sites combined\nNhab[1] <- sum(N[1:33])  # Total abundance for sites in hab A\nNhab[2] <- sum(N[34:66]) # Total abundance for sites in hab B\nNhab[3] <- sum(N[67:100])# Total abundance for sites in hab C\nfor(k in 1:100){         # Predictions of lambda and p ...\n   for(level in 1:3){    #    ... for each level of hab and time factors\n      lam.pred[k, level] <- exp(beta0[level] + beta1[level] * XvegHt[k])\n      logit(p.pred[k, level]) <- alpha0[level] + alpha1[level] * Xwind[k]\n   }\n}\nN.critical <- sum(critical[]) # Number of populations with critical size\n}\")\n```\n:::\n\n\n### Brief summary of the model\n\nThis is known as an \"N-mixture\" model in ecology. The details aren't really important for illustrating the mechanics of converting this model to NIMBLE, but here is a brief summary anyway. The latent abundances `N[i]` at sites `i = 1...M` are assumed to follow a Poisson. The j-th count at the i-th site, `C[i, j]`, is assumed to follow a binomial with detection probability `p[i, j]`. The abundance at each site depends on a habitat-specific intercept and coefficient for vegetation height, with a log link. The detection probability for each sampling occasion depends on a date-specific intercept and coefficient for wind speed. Kéry and Royle concocted this as a simulated example to illustrate the hierarchical modeling approaches for estimating abundance from count data on repeated visits to multiple sites. \n\n## NIMBLE version of the model code\n\nHere is the model converted for use in NIMBLE. In this case, the only changes to the code are to insert some missing index ranges (see comments).\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nimble)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSection6p4_code <- nimbleCode({\n  # Priors\n  for(k in 1:3) {                # Loop over 3 levels of hab or time factors\n    alpha0[k] ~ dunif(-10, 10) # Detection intercepts\n    alpha1[k] ~ dunif(-10, 10) # Detection slopes\n    beta0[k] ~ dunif(-10, 10)  # Abundance intercepts\n    beta1[k] ~ dunif(-10, 10)  # Abundance slopes\n  }\n\n  # Likelihood\n  # Ecological model for true abundance\n  for (i in 1:M){\n    N[i] ~ dpois(lambda[i])\n    log(lambda[i]) <- beta0[hab[i]] + beta1[hab[i]] * vegHt[i]\n    # Some intermediate derived quantities\n    critical[i] <- step(2-N[i])# yields 1 whenever N is 2 or less\n    z[i] <- step(N[i]-0.5)     # Indicator for occupied site\n    # Observation model for replicated counts\n    for (j in 1:J){\n      C[i,j] ~ dbin(p[i,j], N[i])\n      logit(p[i,j]) <- alpha0[j] + alpha1[j] * wind[i,j]\n      }\n  }\n\n  # Derived quantities; unnececssary when running for inference purpose\n  # NIMBLE: We have filled in indices in the next two lines.\n  Nocc <- sum(z[1:100])         # Number of occupied sites among sample of M\n  Ntotal <- sum(N[1:100])       # Total population size at M sites combined\n  Nhab[1] <- sum(N[1:33])  # Total abundance for sites in hab A\n  Nhab[2] <- sum(N[34:66]) # Total abundance for sites in hab B\n  Nhab[3] <- sum(N[67:100])# Total abundance for sites in hab C\n  for(k in 1:100){         # Predictions of lambda and p ...\n    for(level in 1:3){    #    ... for each level of hab and time factors\n      lam.pred[k, level] <- exp(beta0[level] + beta1[level] * XvegHt[k])\n      logit(p.pred[k, level]) <- alpha0[level] + alpha1[level] * Xwind[k]\n      }\n    }\n  # NIMBLE: We have filled in indices in the next line. \n  N.critical <- sum(critical[1:100]) # Number of populations with critical size\n})\n```\n:::\n\n\n##  Simulated data \n\nTo carry this example further, we need some simulated data. Kéry and Royle provide separate code to do this. With NIMBLE we could use the model itself to simulate data rather than writing separate simulation code. But for our goals here, we simply copy Kéry and Royle's simulation code, and we compact it somewhat: \n    \n\n::: {.cell}\n\n```{.r .cell-code}\n# Code from Kery and Royle (2015)\n# Choose sample sizes and prepare obs. data array y\nset.seed(1)                   # So we all get same data set\nM <- 100                      # Number of sites\nJ <- 3                        # Number of repeated abundance measurements\nC <- matrix(NA, nrow = M, ncol = J) # to contain the observed data\n\n# Create a covariate called vegHt\nvegHt <- sort(runif(M, -1, 1)) # sort for graphical convenience\n\n# Choose parameter values for abundance model and compute lambda\nbeta0 <- 0                    # Log-scale intercept\nbeta1 <- 2                    # Log-scale slope for vegHt\nlambda <- exp(beta0 + beta1 * vegHt) # Expected abundance\n\n# Draw local abundance\nN <- rpois(M, lambda)\n\n# Create a covariate called wind\nwind <- array(runif(M * J, -1, 1), dim = c(M, J))\n\n# Choose parameter values for measurement error model and compute detectability\nalpha0 <- -2                        # Logit-scale intercept\nalpha1 <- -3                        # Logit-scale slope for wind\np <- plogis(alpha0 + alpha1 * wind) # Detection probability\n\n# Take J = 3 abundance measurements at each site\nfor(j in 1:J) {\n  C[,j] <- rbinom(M, N, p[,j])\n}\n\n# Create factors\ntime <- matrix(rep(as.character(1:J), M), ncol = J, byrow = TRUE)\nhab <- c(rep(\"A\", 33), rep(\"B\", 33), rep(\"C\", 34))  # assumes M = 100\n\n# Bundle data\n# NIMBLE: For full flexibility, we could separate this list\n#         into constants and data lists.  For simplicity we will keep\n#         it as one list to be provided as the \"constants\" argument.\n#         See comments about how we would split it if desired.\nwin.data <- list(\n    ## NIMBLE: C is the actual data\n    C = C,\n    ## NIMBLE: Covariates can be data or constants\n    ##         If they are data, you could modify them after the model is built\n    wind = wind,\n    vegHt = vegHt,\n    XvegHt = seq(-1, 1,, 100), # Used only for derived quantities\n    Xwind = seq(-1, 1,,100),   # Used only for derived quantities\n    ## NIMBLE: The rest of these are constants, needed for model definition\n    ## We can provide them in the same list and NIMBLE will figure it out.\n    M = nrow(C),\n    J = ncol(C),\n    hab = as.numeric(factor(hab))\n)\n```\n:::\n\n\n##  Initial values \n\nNext we need to set up initial values and choose parameters to monitor in the MCMC output. To do so we will again directly use Kéry and Royle's code.\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nNst <- apply(C, 1, max)+1   # Important to give good inits for latent N\ninits <- function() list(N = Nst,\n                         alpha0 = rnorm(3),\n                         alpha1 = rnorm(3),\n                         beta0 = rnorm(3),\n                         beta1 = rnorm(3))\n\n# Parameters monitored\n# could also estimate N, bayesian counterpart to BUPs before: simply add \"N\" to the list\nparams <- c(\"alpha0\", \"alpha1\", \"beta0\", \"beta1\", \"Nocc\", \"Ntotal\", \"Nhab\", \"N.critical\", \"lam.pred\", \"p.pred\")\n```\n:::\n\n\n##  Run MCMC with `nimbleMCMC`\n\nNow we are ready to run an MCMC in nimble. We will run only one chain, using the same settings as Kéry and Royle. \n    \n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- nimbleMCMC(\n    code = Section6p4_code,\n    constants = win.data, ## provide the combined data & constants as constants\n    inits = inits,\n    monitors = params,\n    niter = 22000,\n    nburnin = 2000,\n    thin = 10)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  [Note] Using 'C' (given within 'constants') as data.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model calculations\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n:::\n\n    \n\n##  Work with the samples \n\nFinally we want to look at our samples. NIMBLE returns samples as a simple matrix with named columns. There are numerous packages for processing MCMC output. If you want to use the `coda` package, you can convert a matrix to a coda mcmc object like this: \n    \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(coda)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'coda'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked _by_ '.GlobalEnv':\n\n    densplot\n```\n\n\n:::\n\n```{.r .cell-code}\ncoda.samples <- as.mcmc(samples)\n```\n:::\n\n\nAlternatively, if you call `nimbleMCMC` with the argument `samplesAsCodaMCMC = TRUE`, the samples will be returned as a coda object.\n\nTo show that MCMC really happened, here is a plot of `N.critical`:\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nplot(jitter(samples[, \"N.critical\"]), xlab = \"iteration\", ylab = \"N.critical\",\n     main = \"Number of populations with critical size\",\n     type = \"l\")\n```\n\n::: {.cell-output-display}\n![](quick-guide-for-converting-from-jags-or-bugs-to-nimble_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n#  Next steps \n\nNIMBLE allows users to customize MCMC and other algorithms in many ways. See the NIMBLE User Manual and web site for more ideas. \n\n##  Smaller steps you may need for converting existing code\n\nIf the main steps above aren't sufficient, consider these additional steps when converting from JAGS, WinBUGS or OpenBUGS to NIMBLE.\n\n  4. Convert any use of truncation syntax \n     * e.g. `x ~ dnorm(0, tau) T(a, b)` should be re-written as `x ~ T(dnorm(0, tau), a, b)`.\n     * If reading model code from a file using `readBUGSmodel`, the `x ~ dnorm(0, tau) T(a, b)` syntax will work.\n  5. Possibly split the `data` into `data` and `constants` for NIMBLE. \n     * NIMBLE has a more general concept of data, so NIMBLE makes a distinction between data and constants. \n     * Constants are necessary to define the model, such as `nsite` in `for(i in 1:nsite) {...}` and constant vectors of factor indices (e.g. `block` in `mu[block[i]]`). \n     * Data are observed values of some variables.\n     * Alternatively, one can provide a list of both constants and data for the `constants` argument to `nimbleModel`, and NIMBLE will try to determine which is which. Usually this will work, but when in doubt, try separating them. \n  6. Possibly update initial values (`inits`). \n     * In some cases, NIMBLE likes to have more complete `inits` than the other packages.\n     * In a model with stochastic indices, those indices should have `inits` values.\n     * When using `nimbleMCMC` or `runMCMC`, `inits` can be a function, as in R packages for calling WinBUGS, OpenBUGS or JAGS. Alternatively, it can be a list.\n     * When you build a model with `nimbleModel` for more control than `nimbleMCMC`, you can provide `inits` as a list. This sets defaults that can be over-ridden with the `inits` argument to `runMCMC`.",
    "supporting": [
      "quick-guide-for-converting-from-jags-or-bugs-to-nimble_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}