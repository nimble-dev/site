{
  "hash": "c418510082c406a161024331c97ed5b2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Building Particle Filters and Particle MCMC in NIMBLE\"\ndate: \"2017-01-09\"\nauthor: \"NIMBLE Development Team\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\ncategories: [\"tutorial\"]\nexecute:\n  freeze: auto\n---\n\nAn Example of Using `nimble`‘s Particle Filtering Algorithms  \n\nThis example shows how to construct and conduct inference on a state space model using particle filtering algorithms. `nimble` currently has versions of the bootstrap filter, the auxiliary particle filter, the ensemble Kalman filter, and the Liu and West filter implemented. Additionally, particle MCMC samplers are available and can be specified for both univariate and multivariate parameters.\n\n# Model Creation\n\nAssume $x_{i}$ is the latent state and $y_{i}$ is the observation at time $i$ for $i=1,\\ldots,t$. We define our state space model as \n\n$$x_{i} \\sim N(a \\cdot x_{i-1} + b, \\sigma_{PN})$$\n$$y_{i} \\sim t_{5}(x_{i}, \\sigma_{OE})$$\n\nwith initial states \n\n$$x_{1} \\sim N\\left(\\frac{b}{1-a}, \\frac{\\sigma_{PN}}{\\sqrt{1-a^2}}\\right)$$\n$$y_{1} \\sim t_{5}(x_{1}, \\sigma_{OE})$$\n\nand prior distributions \n\n$$a \\sim \\text{Unif}(-0.999, 0.999)$$\n$$b \\sim N(0, 1000)$$\n\nwhere $N(\\mu, \\sigma)$ denotes a normal distribution with mean $\\mu$ and standard deviation $\\sigma$, and $t_{\\nu}(\\mu, \\sigma)$ is a shifted, scaled $t$-distribution with center parameter $\\mu$, scale parameter $\\sigma$, and $\\nu$ degrees of freedom. \n\nWe specify and build our state space model below, using $t=10$ time points:\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary('nimbleSMC')\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n\n## define the model\nstateSpaceCode <- nimbleCode({\n    a ~ dunif(-0.9999, 0.9999)\n    b ~ dnorm(0, sd = 1000)\n    sigPN ~ dunif(1e-04, 1)\n    sigOE ~ dunif(1e-04, 1)\n    x[1] ~ dnorm(b/(1 - a), sd = sigPN/sqrt((1-a*a)))\n    y[1] ~ dt(mu = x[1], sigma = sigOE, df = 5)\n    for (i in 2:t) {\n        x[i] ~ dnorm(a * x[i - 1] + b, sd = sigPN)\n        y[i] ~ dt(mu = x[i], sigma = sigOE, df = 5)\n    }\n})\n\n## define data, constants, and initial values  \ndata <- list(\n    y = c(0.213, 1.025, 0.314, 0.521, 0.895, 1.74, 0.078, 0.474, 0.656, 0.802)\n)\nconstants <- list(\n    t = 10\n)\ninits <- list(\n    a = 0,\n    b = .5,\n    sigPN = .1,\n    sigOE = .05\n)\n\n## build the model\nstateSpaceModel <- nimbleModel(stateSpaceCode,\n                              data = data,\n                              constants = constants,\n                              inits = inits,\n                              check = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  [Note] This model is not fully initialized. This is not an error.\n         To see which variables are not initialized, use model$initializeInfo().\n         For more information on model initialization, see help(modelInitialization).\n```\n\n\n:::\n:::\n\n\n# Construct and run a bootstrap filter\n\nWe next construct a bootstrap filter to conduct inference on the latent states of our state space model. Note that the bootstrap filter, along with the auxiliary particle filter and the ensemble Kalman filter, treat the top-level parameters `a, b, sigPN`, and `sigOE` as fixed. Therefore, the bootstrap filter below will proceed as though `a = 0`, `b = .5`, `sigPN = .1`, and `sigOE = .05`, which are the initial values that were assigned to the top-level parameters.\n\nThe bootstrap filter takes as arguments the name of the model and the name of the latent state variable within the model. The filter can also take a control list that can be used to fine-tune the algorithm’s configuration.\n    \n\n::: {.cell}\n\n```{.r .cell-code}\n## build bootstrap filter and compile model and filter\nbootstrapFilter <- buildBootstrapFilter(stateSpaceModel, nodes = 'x')\ncompiledList <- compileNimble(stateSpaceModel, bootstrapFilter)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n```{.r .cell-code}\n## run compiled filter with 10,000 particles.  \n## note that the bootstrap filter returns an estimate of the log-likelihood of the model.\ncompiledList$bootstrapFilter$run(10000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -28.13009\n```\n\n\n:::\n:::\n\n    \n\nParticle filtering algorithms in `nimble` store weighted samples of the filtering distribution of the latent states in the `mvSamples` modelValues object. Equally weighted samples are stored in the `mvEWSamples` object. By default, `nimble` only stores samples from the final time point.\n    \n\n::: {.cell}\n\n```{.r .cell-code}\n## extract equally weighted posterior samples of x[10]  and create a histogram\nposteriorSamples <- as.matrix(compiledList$bootstrapFilter$mvEWSamples)\nhist(posteriorSamples)\n```\n\n::: {.cell-output-display}\n![](building-particle-filters-and-particle-mcmc-in-nimble-2_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nThe auxiliary particle filter and ensemble Kalman filter can be constructed and run in the same manner as the bootstrap filter.\n\n# Conduct inference on top-level parameters using particle MCMC\n\nParticle MCMC can be used to conduct inference on the posterior distribution of both the latent states and any top-level parameters of interest in a state space model. The particle marginal Metropolis-Hastings sampler can be specified to jointly sample the `a`, `b`, `sigPN`, and `sigOE` top level parameters within nimble's MCMC framework as follows:\n    \n\n::: {.cell}\n\n```{.r .cell-code}\n## create MCMC specification for the state space model\nstateSpaceMCMCconf <- configureMCMC(stateSpaceModel, nodes = NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n===== Monitors =====\nthin = 1: a, b, sigOE, sigPN\n===== Samplers =====\n(no samplers assigned)\n===== Comments =====\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  [Warning] No samplers assigned for 14 nodes, use conf$getUnsampledNodes() for node names.\n```\n\n\n:::\n\n```{.r .cell-code}\n## add a block pMCMC sampler for a, b, sigPN, and sigOE \nstateSpaceMCMCconf$addSampler(target = c('a', 'b', 'sigPN', 'sigOE'),\n                              type = 'RW_PF_block', control = list(latents = 'x'))\n\n## build and compile pMCMC sampler\nstateSpaceMCMC <- buildMCMC(stateSpaceMCMCconf)\ncompiledList <- compileNimble(stateSpaceModel, stateSpaceMCMC, resetFunctions = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n```{.r .cell-code}\n## run compiled sampler for 5000 iterations\ncompiledList$stateSpaceMCMC$run(5000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n```{.r .cell-code}\n## create trace plots for each parameter\npar(mfrow = c(2,2))\nposteriorSamps <- coda::as.mcmc(as.matrix(compiledList$stateSpaceMCMC$mvSamples))\ncoda::traceplot(posteriorSamps[,'a'], ylab = 'a')\ncoda::traceplot(posteriorSamps[,'b'], ylab = 'b')\ncoda::traceplot(posteriorSamps[,'sigPN'], ylab = 'sigPN')\ncoda::traceplot(posteriorSamps[,'sigOE'], ylab = 'sigOE')\n```\n\n::: {.cell-output-display}\n![](building-particle-filters-and-particle-mcmc-in-nimble-2_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThe above `RW_PF_block` sampler uses a multivariate normal proposal distribution to sample vectors of top-level parameters. To sample a scalar top-level parameter, use the `RW_PF` sampler instead.",
    "supporting": [
      "building-particle-filters-and-particle-mcmc-in-nimble-2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}