{
  "hash": "2a96d5082d7441180fa13e6e264ca5e6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Writing reversible jump MCMC in NIMBLE\"\ndate: \"2017-02-15\"\nauthor: \"Sally Paganin\"\nformat:\n  html:\n    toc: true\n    toc-depth: 2\ncategories: [\"tutorial\", \"R\"]\nexecute:\n  freeze: true\n---\n\n#  Writing reversible jump MCMC samplers in NIMBLE \n\n##  Introduction \n\nReversible jump Markov chain Monte Carlo (RJMCMC) is a powerful method for drawing posterior samples over multiple models by jumping between models as part of the sampling. For a simple example that I’ll use below, think about a regression model where we don’t know which explanatory variables to include, so we want to do variable selection. There may be a huge number of possible combinations of variables, so it would be nice to explore the combinations as part of one MCMC run rather than running many different MCMCs on some chosen combinations of variables. To do it in one MCMC, one sets up a model that includes all possible variables and coefficients. Then “removing” a variable from the model is equivalent to setting its coefficient to zero, and “adding” it back into the model requires a valid move to a non-zero coefficient. Reversible jump MCMC methods provide a way to do that. \n\nReversible jump is different enough from other MCMC situations that packages like WinBUGS, OpenBUGS, JAGS, and Stan don’t do it. An alternative way to set up the problem, which does not involve the technicality of changing model dimension, is to use indicator variables. An indicator variable is either zero or one and is multiplied by another parameter. Thus when the indicator is 0, the parameter that is multipled by 0 is effectively removed from the model. Darren Wilkinson has a nice old [blog post on using indicator variables for Bayesian variable selection](https://darrenjw.wordpress.com/2012/11/20/getting-started-with-bayesian-variable-selection-using-jags-and-rjags/) in BUGS code. The problem with using indicator variables is that they can create a lot of extra MCMC work and the samplers operating on them may not be well designed for their situation.\n\nNIMBLE lets one program model-generic algorithms to use with models written in the BUGS language. The MCMC system works by first making a configuration in R, which can be modified by a user or a program, and then building and compiling the MCMC. The nimbleFunction programming system makes it easy to write new kinds of samplers.\n\nThe aim of this blog post is to illustrate how one can write reversible jump MCMC in NIMBLE. A variant of this may be incorporated into a later version of NIMBLE. \n\n##  Example model \n\nFor illustration, I’ll use an extremely simple model: linear regression with two candidate explanatory variables. I’ll assume the first, `x1`, should definitely be included. But the analyst is not sure about the second, `x2`, and wants to use reversible jump to include it or exclude it from the model. I won’t deal with the issue of choosing the prior probability that it should be in the model. Instead I’ll just pick a simple choice and stay focused on the reversible jump aspect of the example. The methods below could be applied en masse to large models.\n\nHere I’ll simulate data to use:\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 20\nx1 <- runif(N, -1, 1)\nx2 <- runif(N, -1, 1)\nY <- rnorm(N, 1.5 + 0.5 * x1, sd = 1)\n```\n:::\n\n\nI’ll take two approaches to implementing RJ sampling. In the first, I’ll use a traditional indicator variable and write the RJMCMC sampler to use it. In the second, I’ll write the RJMCMC sampler to incorporate the prior probability of inclusion for the coefficient it is sampling, so the indicator variable won’t be needed in the model.\n\nFirst we’ll need nimble:\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nimble)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nnimble version 1.4.0 is loaded.\nFor more information on NIMBLE and a User Manual,\nplease visit https://R-nimble.org.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'nimble'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:stats':\n\n    simulate\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:base':\n\n    declare\n```\n\n\n:::\n:::\n\n\n##  RJMCMC implementation 1, with indicator variable included \n\nHere is BUGS code for the first method, with an indicator variable written into the model, and the creation of a NIMBLE model object from it. Note that although RJMCMC technically jumps between models of different dimensions, we still start by creating the largest model so that changes of dimension can occur by setting some parameters to zero (or, in the second method, possibly another fixed value). \n    \n\n::: {.cell}\n\n```{.r .cell-code}\nsimpleCode1 <- nimbleCode({\n    beta0 ~ dnorm(0, sd = 100)\n    beta1 ~ dnorm(0, sd = 100)\n    beta2 ~ dnorm(0, sd = 100)\n    sigma ~ dunif(0, 100)\n    z2 ~ dbern(0.8)  ## indicator variable for including beta2\n    beta2z2 <- beta2 * z2\n    for(i in 1:N) {\n        Ypred[i] <- beta0 + beta1 * x1[i] + beta2z2 * x2[i]\n        Y[i] ~ dnorm(Ypred[i], sd = sigma)\n    }\n})\n\nsimpleModel1 <- nimbleModel(simpleCode1,\n                            data = list(Y = Y, x1 = x1, x2 = x2),\n                            constants = list(N = N),\n                            inits = list(beta0 = 0, beta1 = 0, beta2 = 0, sigma = sd(Y), z2 = 1))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n:::\n\n\nNow here are two custom samplers. The first one will sample `beta2` **only** if the indicator variable `z2` is 1 (meaning that `beta2` is included in the model). It does this by containing a regular random walk sampler but only calling it when the indicator is 1 (we could perhaps set it up to contain _any_ sampler to be used when `z2` is 1, but for now it’s a random walk sampler). The second sampler makes reversible jump proposals to move `beta2` in and out of the model. When it is out of the model, both `beta2` and `z2` are set to zero. Since `beta2` will be zero every time `z2` is zero, we don’t really need `beta2z2`, but it ensures correct behavior in other cases, like if someone runs default samplers on the model and expects the indicator variable to do its job correctly. For use in reversible jump, `z2`’s role is really to trigger the prior probability (set to 0.8 in this example) of being in the model. \n\nDon’t worry about the warning message emitted by NIMBLE. They are there because when a nimbleFunction is defined it tries to make sure the user knows anything else that needs to be defined.\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nRW_sampler_nonzero_indicator <- nimbleFunction(\n    contains = sampler_BASE,\n    setup = function(model, mvSaved, target, control) {\n        regular_RW_sampler <- sampler_RW(model, mvSaved, target = target, control = control$RWcontrol)\n        indicatorNode <- control$indicator\n    },\n    run = function() {\n        if(model[[indicatorNode]] == 1) regular_RW_sampler$run()\n    },\n    methods = list(\n        reset = function() {regular_RW_sampler$reset()}\n    ))\n\nRJindicatorSampler <- nimbleFunction(\n    contains = sampler_BASE,\n    setup = function( model, mvSaved, target, control ) {\n        ## target should be the name of the indicator node, 'z2' above\n        ## control should have an element called coef for the name of the corresponding coefficient, 'beta2' above.  \n        coefNode <- control$coef\n        scale <- control$scale\n        calcNodes <- model$getDependencies(c(coefNode, target))\n    },\n    run = function( ) { ## The reversible-jump updates happen here.\n        currentIndicator <- model[[target]]\n        currentLogProb <- model$getLogProb(calcNodes)\n        if(currentIndicator == 1) {\n            ## propose removing it\n            currentCoef <- model[[coefNode]]\n            logProbReverseProposal <- dnorm(0, currentCoef, sd = scale, log = TRUE)\n            model[[target]] <<- 0\n            model[[coefNode]] <<- 0\n            proposalLogProb <- model$calculate(calcNodes)\n            log_accept_prob <- proposalLogProb - currentLogProb + logProbReverseProposal\n        } else {\n            ## propose adding it\n            proposalCoef <- rnorm(1, 0, sd = scale)\n            model[[target]] <<- 1\n            model[[coefNode]] <<- proposalCoef\n            logProbForwardProposal <- dnorm(0, proposalCoef, sd = scale, log = TRUE)\n            proposalLogProb <- model$calculate(calcNodes)\n            log_accept_prob <- proposalLogProb - currentLogProb - logProbForwardProposal\n        }\n        accept <- decide(log_accept_prob)\n        if(accept) {\n            copy(from = model, to = mvSaved, row = 1, nodes = calcNodes, logProb = TRUE)\n        } else {\n            copy(from = mvSaved, to = model, row = 1, nodes = calcNodes, logProb = TRUE)\n        }\n    },\n    methods = list(reset = function() {\n    })\n)\n```\n:::\n\n\nNow we’ll set up and run the samplers:\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nmcmcConf1 <- configureMCMC(simpleModel1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n===== Monitors =====\nthin = 1: beta0, beta1, beta2, sigma, z2\n===== Samplers =====\nRW sampler (1)\n  - sigma\nconjugate sampler (3)\n  - beta0\n  - beta1\n  - beta2\nbinary sampler (1)\n  - z2\n```\n\n\n:::\n\n```{.r .cell-code}\nmcmcConf1$removeSamplers('z2')\nmcmcConf1$addSampler(target = 'z2',\n                     type = RJindicatorSampler,\n                     control = list(scale = 1, coef = 'beta2'))\nmcmcConf1$removeSamplers('beta2')\nmcmcConf1$addSampler(target = 'beta2',\n                     type = 'RW_sampler_nonzero_indicator',\n                     control = list(indicator = 'z2',\n                                    RWcontrol = list(adaptive = TRUE,\n                                                   adaptInterval = 100,\n                                                   scale = 1,\n                                                   log = FALSE,\n                                                   reflective = FALSE)))\n\nmcmc1 <- buildMCMC(mcmcConf1)\ncompiled1 <- compileNimble(simpleModel1, mcmc1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n```{.r .cell-code}\ncompiled1$mcmc1$run(10000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n```{.r .cell-code}\nsamples1 <- as.matrix(compiled1$mcmc1$mvSamples)\n```\n:::\n\n\nHere is a trace plot of the beta2 (slope) samples. The thick line at zero corresponds to having beta2 removed from the model. \n    \n\n::: {.cell}\n\n```{.r .cell-code}\nplot(samples1[,'beta2'], type = 'l')\n```\n\n::: {.cell-output-display}\n![](writing-reversible-jump-mcmc-in-nimble_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nAnd here is a trace plot of the z2 (indicator variable) samples.\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nplot(samples1[,'z2'], type = 'l')\n```\n\n::: {.cell-output-display}\n![](writing-reversible-jump-mcmc-in-nimble_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nThe chains look reasonable.\n\nAs a quick check of reasonableness, let’s compare the `beta2` samples to what we’d get if it was always included in the model. I’ll do that by setting up default samplers and then removing the sampler for `z2` (and `z2` should be 1).\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nmcmcConf1b <- configureMCMC(simpleModel1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n===== Monitors =====\nthin = 1: beta0, beta1, beta2, sigma, z2\n===== Samplers =====\nRW sampler (1)\n  - sigma\nconjugate sampler (3)\n  - beta0\n  - beta1\n  - beta2\nbinary sampler (1)\n  - z2\n```\n\n\n:::\n\n```{.r .cell-code}\nmcmcConf1b$removeSamplers('z2')\nmcmc1b <- buildMCMC(mcmcConf1b)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  [Warning] No samplers assigned for 1 node, use conf$getUnsampledNodes() for node name.\n```\n\n\n:::\n\n```{.r .cell-code}\ncompiled1b <- compileNimble(simpleModel1, mcmc1b)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n```{.r .cell-code}\ncompiled1b$mcmc1b$run(10000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n```{.r .cell-code}\nsamples1b <- as.matrix(compiled1b$mcmc1b$mvSamples)\nplot(samples1b[,'beta2'], type = 'l')\n```\n\n::: {.cell-output-display}\n![](writing-reversible-jump-mcmc-in-nimble_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\nqqplot(samples1[ samples1[,'z2'] == 1, 'beta2'], samples1b[,'beta2'])\nabline(0,1)\n```\n\n::: {.cell-output-display}\n![](writing-reversible-jump-mcmc-in-nimble_files/figure-html/unnamed-chunk-8-2.png){width=672}\n:::\n:::\n\n\nThat looks correct, in the sense that the distribution of `beta2` given that it’s in the model (using reversible jump) should match the distribution of `beta2` when it is  \nalways in the model.\n\n##  RJ implementation 2, without indicator variables \n\nNow I’ll set up the second version of the model and samplers. I won’t include the indicator variable in the model but will instead include the prior probability for inclusion in the sampler. One added bit of generality is that being “out of the model” will be defined as taking some fixedValue, to be provided, which will typically but not necessarily be zero. These functions are very similar to the ones above.\n\nHere is the code to define and build a model without the indicator variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimpleCode2 <- nimbleCode({\n    beta0 ~ dnorm(0, sd = 100)\n    beta1 ~ dnorm(0, sd = 100)\n    beta2 ~ dnorm(0, sd = 100)\n    sigma ~ dunif(0, 100)\n    for(i in 1:N) {\n        Ypred[i] <- beta0 + beta1 * x1[i] + beta2 * x2[i]\n        Y[i] ~ dnorm(Ypred[i], sd = sigma)\n    }\n})\n\nsimpleModel2 <- nimbleModel(simpleCode2,\n                            data = list(Y = Y, x1 = x1, x2 = x2),\n                            constants = list(N = N),\n                            inits = list(beta0 = 0, beta1 = 0, beta2 = 0, sigma = sd(Y)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n:::\n\n\nAnd here are the samplers (again, ignore the warning): \n    \n\n::: {.cell}\n\n```{.r .cell-code}\nRW_sampler_nonzero <- nimbleFunction(\n    ## \"nonzero\" is a misnomer because it can check whether it sits at any fixedValue, not just 0\n    contains = sampler_BASE,\n    setup = function(model, mvSaved, target, control) {\n        regular_RW_sampler <- sampler_RW(model, mvSaved, target = target, control = control$RWcontrol)\n        fixedValue <- control$fixedValue\n    },\n    run = function() { ## Now there is no indicator variable, so check if the target node is exactly\n                       ## equal to the fixedValue representing \"not in the model\".\n        if(model[[target]] != fixedValue) regular_RW_sampler$run()\n    },\n    methods = list(\n        reset = function() {regular_RW_sampler$reset()}\n    ))\n\nRJsampler <- nimbleFunction(\n    contains = sampler_BASE,\n    setup = function( model, mvSaved, target, control ) {\n        ## target should be a coefficient to be set to a fixed value (usually zero) or not\n        ## control should have an element called fixedValue (usually 0),\n        ##    a scale for jumps to and from the fixedValue,\n        ##    and a prior prob of taking its fixedValue\n        fixedValue <- control$fixedValue\n        scale <- control$scale\n        ## The control list contains the prior probability of inclusion, and we can pre-calculate\n        ## this log ratio because it's what we'll need later.\n        logRatioProbFixedOverProbNotFixed <- log(control$prior) - log(1-control$prior)\n        calcNodes <- model$getDependencies(target)\n    },\n    run = function( ) { ## The reversible-jump moves happen here\n        currentValue <- model[[target]]\n        currentLogProb <- model$getLogProb(calcNodes)\n        if(currentValue != fixedValue) { ## There is no indicator variable, so check if current value matches fixedValue\n            ## propose removing it (setting it to fixedValue)\n            logProbReverseProposal <- dnorm(fixedValue, currentValue, sd = scale, log = TRUE)\n            model[[target]] <<- fixedValue\n            proposalLogProb <- model$calculate(calcNodes)\n            log_accept_prob <- proposalLogProb - currentLogProb - logRatioProbFixedOverProbNotFixed + logProbReverseProposal\n        } else {\n            ## propose adding it\n            proposalValue <- rnorm(1, fixedValue, sd = scale)\n            model[[target]] <<- proposalValue\n            logProbForwardProposal <- dnorm(fixedValue, proposalValue, sd = scale, log = TRUE)\n            proposalLogProb <- model$calculate(calcNodes)\n            log_accept_prob <- proposalLogProb - currentLogProb + logRatioProbFixedOverProbNotFixed - logProbForwardProposal\n        }\n        accept <- decide(log_accept_prob)\n        if(accept) {\n            copy(from = model, to = mvSaved, row = 1, nodes = calcNodes, logProb = TRUE)\n        } else {\n            copy(from = mvSaved, to = model, row = 1, nodes = calcNodes, logProb = TRUE)\n        }\n    },\n    methods = list(reset = function() {\n    })\n)\n```\n:::\n\n\nNow let’s set up and use the samplers\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nmcmcConf2 <- configureMCMC(simpleModel2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n===== Monitors =====\nthin = 1: beta0, beta1, beta2, sigma\n===== Samplers =====\nRW sampler (1)\n  - sigma\nconjugate sampler (3)\n  - beta0\n  - beta1\n  - beta2\n```\n\n\n:::\n\n```{.r .cell-code}\nmcmcConf2$removeSamplers('beta2')\n\nmcmcConf2$addSampler(target = 'beta2',\n                     type = 'RJsampler',\n                     control = list(fixedValue = 0, prior = 0.8, scale = 1))\nmcmcConf2$addSampler(target = 'beta2',\n                     type = 'RW_sampler_nonzero',\n                     control = list(fixedValue = 0,\n                                     RWcontrol = list(adaptive = TRUE,\n                                     adaptInterval = 100,\n                                     scale = 1,\n                                     log = FALSE,\n                                     reflective = FALSE)))\n\nmcmc2 <- buildMCMC(mcmcConf2)\ncompiled2 <- compileNimble(simpleModel2, mcmc2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n```{.r .cell-code}\ncompiled2$mcmc2$run(10000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n```{.r .cell-code}\nsamples2 <- as.matrix(compiled2$mcmc2$mvSamples)\n```\n:::\n\n\nAnd again let’s look at the samples. As above, the horizontal line at 0 represents having beta2 removed from the model. \n    \n\n::: {.cell}\n\n```{.r .cell-code}\nplot(samples2[,'beta2'], type = 'l')\n```\n\n::: {.cell-output-display}\n![](writing-reversible-jump-mcmc-in-nimble_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nNow let’s compare those results to results from the first method, above. They should match.\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nmean(samples1[,'beta2']==0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.186\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(samples2[,'beta2']==0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1939\n```\n\n\n:::\n\n```{.r .cell-code}\nqqplot(samples1[ samples1[,'beta2'] != 0,'beta2'], samples2[samples2[,'beta2'] != 0,'beta2'])\nabline(0,1)\n```\n\n::: {.cell-output-display}\n![](writing-reversible-jump-mcmc-in-nimble_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nThey match well.  \n\n###  How to apply this for larger models. \n\nThe samplers above could be assigned to arbitrary nodes in a model. The only additional code would arise from adding more samplers to an MCMC configuration. It would also be possible to refine the reversible-jump step to adapt the scale of its jumps in order to achieve better mixing. For example, one could try [ this method by Ehlers and Brooks](http://onlinelibrary.wiley.com/doi/10.1111/j.1467-9469.2008.00606.x/abstract). We’re interested in hearing from you if you plan to try using RJMCMC on your own models.\n\n",
    "supporting": [
      "writing-reversible-jump-mcmc-in-nimble_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}