---
title: "Using nimbleQuad for maximum likelihood estimation and deterministic posterior approximation"
author: "Paul van Dam-Bates and Christopher Paciorek"
date: "2026-01-29"
categories: ['R','tutorial']
bibliography: nimbleQuad_references.bib
execute:
  freeze: true
---


## Introduction


The new `nimbleQuad` package provides quadrature-based inference methods that use Laplace and Adaptive Gauss-Hermite Quadrature (AGHQ) approximation. It has two main components:

1. Laplace and AGHQ approximations for marginalizing over latent nodes (e.g., random effects) to perform approximate maximum likelihood estimation.
2. Deterministic nested quadrature methods for posterior approximation using Laplace approximation for the inner marginalization of the latent nodes and general quadrature methods for outer marginalization of the parameter nodes. These methods borrow ideas from the popular INLA approach [@rue2009approximate] and from the extended Gaussian latent model approach provided in the R `aghq` package [@stringer2023fast].

The first component was present in the core `nimble` package until version 1.4.0 and is now in `nimbleQuad`. The second component is a new feature.

By providing these methods in the NIMBLE system, via `nimbleQuad`, users can use the methods on models constructed using the NIMBLE model language (which extends the BUGS model language) and  can also customize and extend the algorithms.

In this document we will introduce some of the workflow and show the flexibility available when using `buildNestedApprox` for posterior approximations.

```{r, echo=FALSE}
load('nimbleQuad_hmc_density_objects.Rda')
```

Additional details about nimbleQuad can be found in [the NIMBLE User Manual](https://r-nimble.org/manual/cha-laplace.html) and [the nimbleQuad vignette](https://r-nimble.org/vignettes/nimbleQuad.html).

### What is NIMBLE?

[NIMBLE](https://r-nimble.org) is a system for writing hierarchical statistical models and algorithms.  It is distributed as the R package, [nimble](https://CRAN.R-project.org/package=nimble). NIMBLE includes:

1. A dialect of the BUGS model language that is extensible.  NIMBLE uses almost the same model code as WinBUGS, OpenBUGS, and JAGS.  Being "extensible" means that it is possible to write new functions and distributions and use them in your models.

2. An algorithm library including Markov chain Monte Carlo (MCMC) and other methods.

3. A compiler that generates C++ for each model and algorithm, compiles the C++, and lets you use it from R.  You don't need to know anything about C++ to use nimble.

### Illustrative Example

For this vignette we will use the salamander example from the R package `glmmTMB`. Example usage of this model can be seen by running `?glmmTMB`. The data are repeated counts, $y$, of salamanders at multiple sites, which are zero-inflated. Some of the sites are mined, and some are not ($x$). Based on `glmmTMB`, we can analyze these data as

$$
  y_i|z_i \sim \text{Poisson}(z_i\lambda_i) 
$$

$$
  z_i \sim \text{Bernoulli}(1-p_i)
$$

$$
  \text{log}(\lambda_i) = \beta x_i + u_{site_i}
$$

$$
\text{logit}(p_i) = \alpha_0 x_i
$$

$$
u_{j} \sim \text{Normal}(0, \sigma^2)
$$

The maximum likelihood estimator can be found with `glmmTMB`.

```{r, message = FALSE, warning = FALSE}
library(glmmTMB)
data(Salamanders)
fit_tmb <- glmmTMB(count ~ spp * mined + (1|site), zi=~1, family=poisson, data=Salamanders)
```

We can also fit this model in `INLA` to get the approximate posterior using the "zeroinflatedpoisson1" model family.

```{r, message = FALSE, warning = FALSE}
library(INLA)
fit_inla <- inla( count ~ spp * mined + f(site, model="iid"), 
  quantiles = c(.025,.25,.5,.75,.975), family= "zeroinflatedpoisson1", data=Salamanders,
  control.inla = list(int.strategy = "ccd"))
```

## Building a GLMM in NIMBLE

To write this model in NIMBLE we will first write a zero-inflated Poisson distribution that marginalizes over the indirectly observed discrete value $z$. When $y=0$, $z$ is a discrete latent variable. In order to use the methods in `nimbleQuad`, all the latent variables in this model must be continuous.

`nimbleQuad` relies on automatic differentiation (AD) to take derivatives. To include AD in a `nimbleFunction` we must set `buildDerivs = 'run'`.

A nimbleFunction, `rZIP`, to simulate from the distribution is also provided for convenience, although this is not strictly needed for this model to fit.

```{r, output=FALSE}
library(nimbleQuad)
```

```{r}
dZIP <- nimbleFunction(
 run = function(x = double(), lambda = double(),
                zeroProb = double(), log = logical(0, default = 0)) {
   returnType(double())
   ## For use with AD, we cannot use an `if` statement to handle the mixture.
   prob <- zeroProb * dbinom(x, size = 1, prob = 0) + (1 - zeroProb) * dpois(x, lambda)
   if (log) return(log(prob))
     return(prob)
   },
   buildDerivs = 'run'   # Needed when used with AD-based algorithms.
)

rZIP <- nimbleFunction(
 run = function(n = integer(), lambda = double(), zeroProb = double()) {
   returnType(double())
   isStructuralZero <- rbinom(1, prob = zeroProb, size = 1)
   if (isStructuralZero) return(0)
   return(rpois(1, lambda))
})
```

We will use prior distributions to match the default priors in the `INLA` model that was fit above to allow direct comparison of results. See `inla.priors.used(fit_inla)` for a description of the default priors. INLA places a logit-normal prior on $p$. For convenience, we will write our own logit-normal prior. In this case, we explicitly register the distribution to tell NIMBLE the range of possible values, needed for use in NIMBLE's parameter transformation system.


```{r}
dlogitnormal = nimbleFunction(
  run = function(x = double(), mean = double(), sd = double(), 
      log = logical(0, default = 0)){
    ans <- dnorm(logit(x), mean = mean, sd = sd, log = TRUE) - log(x) - log(1-x)
    returnType(double())
    if(log) return(ans)
    else return(exp(ans))
  },
  buildDerivs = 'run'
)

registerDistributions(list(
  dlogitnormal = list(BUGSdist = "dlogitnormal(mean, sd)", range = c(0,1))
))
```

If not trying to use the same model as INLA, one might choose different priors, and one would not necessarily need to define the logit-normal distribution.

Following INLA, we use a completely flat prior on the intercept `dflat`, a gamma prior on precision `tau_re` and a logit-normal on `p`. We can now write the model code, and then provide constants and data to build the model. 


```{r}
code <- nimbleCode({
  beta[1] ~ dflat()
  for( i in 2:np ) 
    beta[i] ~ dnorm(0, tau = 0.001) 
  tau_re ~ dgamma(shape = 1, rate = 5e-5)
  p ~ dlogitnormal(mean = -1, sd = 1/sqrt(0.2))
  
  for(i in 1:nsites) 
    re[i] ~ dnorm(0, tau = tau_re)

  for( i in 1:nobs ){
    log(lam[i]) <- sum(beta[1:np]*X[i,1:np]) + re[site[i]]
    count[i] ~ dZIP(lambda = lam[i], zeroProb = p)
  }
})

nimconst <- list()
nimconst$X <- as.matrix(model.matrix( ~ spp * mined, data = Salamanders ))
nimconst$np <- ncol(nimconst$X)
nimconst$nobs <- nrow(nimconst$X)
nimconst$site <- as.numeric(factor(Salamanders$site))
nimconst$nsites <- max(nimconst$site)

nimdata <- list()
nimdata$count <- Salamanders$count

inits <- list(p = .29,
  tau_re = 3,
  re = rnorm(nimconst$nsites,0,0.1),
  beta = rnorm(nimconst$np))

m <- nimbleModel(code, data = nimdata, constants = nimconst, inits = inits, buildDerivs = TRUE)
cm <- compileNimble(m)
```

Note that since nimbleQuad methods use NIMBLE's automatic differentiation (AD) system, we set `buildDerivs = TRUE` when building the nimble model.

## Using the Laplace Approximation

We can find the maximum likelihood estimate by using `buildLaplace` (or `buildAGHQ` if we want more quadrature nodes for marginalizing over the random effects, as discussed below).

```{r}
laplace <- buildLaplace(model = m)
claplace <- compileNimble(laplace)

nimble_fit <- runLaplace(claplace)
```

NIMBLE reports that it is able to use 23 separate (one-dimensional) Laplace approximations (because the random effects, plus their data dependencies, are conditionally independent). 

Let's compare the results with `glmmTMB`. The results are very similar.

```{r}
nimble_params <- nimble_fit$summary$params
nimble_fixef <- nimble_params[grep("beta", rownames(nimble_params)),]

plot(nimble_fixef[, "estimate"], fixef(fit_tmb)$cond, 
  xlab = "NIMBLE Estimate", ylab = "glmmTMB Estimate")
abline(a = 0, b = 1, lty = 2)

# logit(p):
fit_tmb$fit$par["betazi"]     # TMB
logit(nimble_params["p",1])   # NIMBLE

# tau_re
exp(-2*fit_tmb$fit$par["theta"])  # TMB
nimble_params["tau_re",1]         # NIMBLE
```

It can be helpful to check the Laplace approximation at the MLE by increasing the number of quadrature nodes using AGHQ. If the likelihood is very different when increasing the number of quadrature nodes, that indicates that Laplace was not a good approximation to the marginal likelihood. In this particular case, since we have have conditionally independent random effects (and therefore a set of 1-dimensional AGHQ approximations), increasing the number of quadrature nodes will be relatively quick, but in other cases it can be very slow.

```{r}
claplace$calcLogLik(nimble_fit$summary$params[, 'estimate'], trans = FALSE)
claplace$updateSettings(nQuad = 5)
claplace$calcLogLik(nimble_fit$summary$params[, 'estimate'], trans = FALSE)
claplace$updateSettings(nQuad = 11)
claplace$calcLogLik(nimble_fit$summary$params[, 'estimate'], trans = FALSE)
```

## Posterior Approximation

Posterior approximation is done by `buildNestedApprox` (to build the approximation) and `runNestedApprox` (to calculate the approximation). Note that the setup for `buildNestedApprox`is similar to `buildLaplace` except that we refer to the combination of random effects and fixed effects as `latentNodes` and the hyperparameters as `paramNodes`, which we will refer to more generally as the "parameters". Including fixed effects with the random effects reduces the dimension of the outer quadrature, which reduces computation time. However, in some cases one may want to include the fixed effects in the `paramNodes`, as the choice of where to include the fixed effects can affect statistical performance. If the user does not specify `latentNodes` and `paramNodes`, NIMBLE will automatically determine them based on the graphical structure of the model, and the user can check that a reasonable determination has been made.

```{r}
approx <- buildNestedApprox(model = m, 
                            paramNodes = c('p', 'tau_re'), 
                            latentNodes = c('beta', 're'))
capprox <- compileNimble(approx, project = m)
```

We then use `runNestedApprox` to run the basic approximation and apply various methods to the output object to carry out further inference. The steps include:

1. Find posterior mode of the parameters using Laplace (or AGHQ) to marginalize over the latent nodes.
2. Use an *integration-free* method analogous to that of INLA to quickly approximate the marginal posterior distribution of each parameter [@martins2013bayesian].
3. Calculate the posterior density of the parameters across the parameter quadrature grid (the default grid uses the CCD (central composite design) approach when the number of parameters is greater than two). In addition, a quadrature-based marginal log likelihood is produced based on this computation.
4. Sample from the joint posterior of the `latentNodes` using a mixture of multivariate normal distributions with mean, covariance, and weights obtained at each grid point in the parameter quadrature grid.

Using the integration-free method is the fastest way to produce marginal posterior density estimates of the parameters. Following the methodology of INLA, this is done by using an asymmetric multivariate normal distribution to approximate the posterior density of the parameters.

If more accuracy is required, quadrature can be used such as AGHQ to marginalize over the other parameters (similar to the R package `aghq`). Here the user can choose between AGHQ, CCD, sparse AGHQ, or a user-provided quadrature rule, as discussed further below). Marginal density values are computed at a fixed set of points and then a spline is used for computations with the univariate density.

For inference on the latent nodes, at each point in the parameter grid, Laplace is used to marginalize the latent nodes to calculate the posterior density for the point, which requires an inner optimization. This can be computationally expensive (particularly with a large number of latent nodes), scaling with the number of grid points. CCD is the default (as is done in INLA) because it scales well to higher dimensions. Alternatively, an AGHQ grid can be used. This will be computationally more expensive because there are more grid points but potentially more accurate. The user can also provide their own grid. By default, we do not do compute the parameter grid when calling `runNestedApprox` unless requested, because the integration-free estimates do not require it. However, it is necessary for inference on the latent nodes and is done automatically when the latent nodes are sampled (via `sampleLatents`).


Here is the initial (integration-free) inference for the parameters. We compare results to samples from a long HMC (MCMC) run.


```{r}
#| fig-width: 8
result <- runNestedApprox(approx = capprox)
result

par(mfrow = c(1,2))

result$plotMarginal("tau_re", xlim = c(0,17), lwd=2)
lines(hmc_tau_re$x, inla.dmarginal(hmc_tau_re$x, fit_inla$marginals.hyperpar[[2]]), col = 'red')
lines(hmc_tau_re, col = 'green')
legend("topright", legend = c("NIMBLE\nnested approx", "INLA", "HMC"),
  col = c('black','red','green'), lty = rep(1,3), cex = 0.75, bty = 'n')

result$plotMarginal("p", lwd=2)
lines(hmc_p$x, inla.dmarginal(hmc_p$x, fit_inla$marginals.hyperpar[[1]]), col = 'red')
lines(hmc_p, col = 'green')
```

The nested approximation and INLA results match MCMC well, though for some reason the densities plotted by INLA don't quite integrate to one and therefore lies above the other two lines.

Here is the sampling-based inference for the latent nodes. The density estimates match HMC reasonably well, but not quite as well as INLA for the fixed effects.

```{r}
#| fig-width: 8
#| fig-height: 4

# remove these lines later
# hmc_beta1 <- density(samples_hmc[ , 'beta[1]'])
# hmc_beta2 <- density(samples_hmc[ , 'beta[2]'])
# hmc_re1 <- density(samples_hmc[ , 're[1]'])

result$sampleLatents(10000)
par(mfrow = c(1,3))
plot(density(result$samples[, "beta[1]"]), main = "", xlab = "beta[1]")
lines(hmc_beta1$x, inla.dmarginal(hmc_beta1$x, fit_inla$marginals.fixed[[1]]), col = 'red')
lines(hmc_beta1, col = 'green')
plot(density(result$samples[, "beta[2]"]), main = "", xlab = "beta[2]")
lines(hmc_beta2$x, inla.dmarginal(hmc_beta2$x, fit_inla$marginals.fixed[[2]]), col = 'red')
lines(hmc_beta2, col = 'green')
plot(density(result$samples[, "re[1]"]), main = "", xlab = "re[1]")
lines(hmc_re1$x, inla.dmarginal(hmc_re1$x, fit_inla$marginals.random[[1]][[1]]), col = 'red')
lines(hmc_re1, col = 'green')
```

### Improving the Parameter Marginals

Although the integration-free method is fast and performs reasonably well, it may be that the user wishes to get a more exact marginal. This is done individually for each parameter of interest, marginalizing over the remaining parameters using an outer quadrature rule (AGHQ, CCD, AGHQSPARSE, USER), with AGHQ as the default. We choose the number of quadrature points for marginalization (`nQuad`) as well as the number of points along a grid to evaluate the marginal (`nMarginalGrid`). Increasing either can improve performance but at the expense of additional computation and generally with diminishing improvement.


```{r}
result  # Original (integration-free) parameter estimates

result$improveParamMarginals(nodes = c('tau_re', 'p'),
  nMarginalGrid = 9, nQuad = 3, quadRule = "AGHQ")

```

Comparing to the quantiles from the integration-free approach, the differences are generally minor, but there is a noticeable difference in the right tail for `tau_re`.

### Customizing the Quadrature Grid

For the salamanders example, we have two parameters, for which `nimbleQuad` defaults to using AGHQ as the parameter grid. The grid points are skewed based on the skew from the asymmetric multivariate normal approximation, and then scaled using spectral decomposition (or Cholesky decomposition).

For more than two parameters, `nimbleQuad` defaults to using a CCD grid, also used by INLA.

The user may also provide their own parameter grid. This must be written as a `nimbleFunction` with some specific components and is described in [the nimbleQuad vignette](https://r-nimble.org/vignettes/nimbleQuad.html#customizing-the-quadrature-grid).


### Sampling from the posterior over parameters

The user may also choose to sample from the asymmetric multivariate normal approximation to make inference about the parameters. This can be particularly useful when making inference on parameters with dimension changes (e.g., proportions with a Dirichlet prior or elements of a covariance matrix, such as one with a Wishart or LKJ prior) or generally making inference about functionals of multiple parameters.

```{r}
samples_params <- result$sampleParams(10000)
result$plotMarginal("tau_re", xlim = c(0,17), lwd=2)
lines(density(samples_params[,2]), col = 'black', lty = 2)
lines(hmc_tau_re, col = 'green')
legend("topright", legend = c("nested approx", "nested approx, samples", "HMC"),
  col = c('black','black','green'), lty = c(1,2,1), bty = 'n')
```

### Model selection and the marginal likelihood

With proper priors, one can calculate $p(y)=\int p(y|\theta)p(\theta)d\theta$, the marginal likelihood, which is useful for model selection. This is reported with the nested approximation results, initially using an asymmetric multivariate normal approximation to the joint posterior of the parameters. An improved estimate based on quadrature over the parameter grid (by default using AGHQ) can be obtained using the `calcMarginalLogLikImproved` method of the nested approximation object.

However, much caution is warranted. The quantity is ill-defined when the prior is improper. Furthermore, even with proper priors, if the prior is diffuse, the integral will generally average over values of the parameters that give very poor fits to the data, which can produce misleading results for model selection. 
