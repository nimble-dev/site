---
title: "Building Particle Filters and Particle MCMC in NIMBLE"
date: "2017-01-09"
author: "nimble-admin"
format:
  html:
    toc: true
    toc-depth: 2
categories: ["NIMBLE", "R", "Statistics"]
---

An Example of Using `nimble`‘s Particle Filtering Algorithms  

This example shows how to construct and conduct inference on a state space model using particle filtering algorithms. `nimble` currently has versions of the bootstrap filter, the auxiliary particle filter, the ensemble Kalman filter, and the Liu and West filter implemented. Additionally, particle MCMC samplers are available and can be specified for both univariate and multivariate parameters.

# Model Creation

Assume ![x_{i}](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=x_%7Bi%7D&bg=ffffff&fg=000000&s=0) is the latent state and ![y_{i}](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=y_%7Bi%7D&bg=ffffff&fg=000000&s=0) is the observation at time ![i](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=i&bg=ffffff&fg=000000&s=0) for ![i=1,\\ldots,t](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=i%3D1%2C%5Cldots%2Ct&bg=ffffff&fg=000000&s=0). We define our state space model as 

![x_{i} \\sim N\(a \\cdot x_{i-1} + b, \\sigma_{PN}\)](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=x_%7Bi%7D+%5Csim+N%28a+%5Ccdot+x_%7Bi-1%7D+%2B+b%2C+%5Csigma_%7BPN%7D%29&bg=ffffff&fg=000000&s=0)  
![ y_{i} \\sim t_{5}\(x_{i}, \\sigma_{OE}\)](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=+y_%7Bi%7D+%5Csim+t_%7B5%7D%28x_%7Bi%7D%2C+%5Csigma_%7BOE%7D%29&bg=ffffff&fg=000000&s=0)

with initial states 

![  x_{1} \\sim N\(\\frac{b}{1-a}, \\frac{\\sigma_{PN}}{\\sqrt{1-a^2}}\)](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=++x_%7B1%7D+%5Csim+N%28%5Cfrac%7Bb%7D%7B1-a%7D%2C+%5Cfrac%7B%5Csigma_%7BPN%7D%7D%7B%5Csqrt%7B1-a%5E2%7D%7D%29&bg=ffffff&fg=000000&s=0)  
![ y_{1} \\sim t_{5}\(x_{1}, \\sigma_{OE}\)](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=+y_%7B1%7D+%5Csim+t_%7B5%7D%28x_%7B1%7D%2C+%5Csigma_%7BOE%7D%29&bg=ffffff&fg=000000&s=0)

and prior distributions 

![ a \\sim Unif\(-0.999, 0.999\) ](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=+a+%5Csim+Unif%28-0.999%2C+0.999%29+&bg=ffffff&fg=000000&s=0)  
![ b \\sim N\(0, 1000\) ](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=+b+%5Csim+N%280%2C+1000%29+&bg=ffffff&fg=000000&s=0)

where ![N\(\\mu, \\sigma\)](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=N%28%5Cmu%2C+%5Csigma%29&bg=ffffff&fg=000000&s=0) denotes a normal distribution with mean ![\\mu](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=%5Cmu&bg=ffffff&fg=000000&s=0) and standard deviation ![\\sigma](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=%5Csigma&bg=ffffff&fg=000000&s=0), and ![t_{\\nu}\(\\mu, \\sigma\)](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=t_%7B%5Cnu%7D%28%5Cmu%2C+%5Csigma%29&bg=ffffff&fg=000000&s=0) is a shifted, scaled ![t](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=t&bg=ffffff&fg=000000&s=0)-distribution with center parameter ![\\mu](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=%5Cmu&bg=ffffff&fg=000000&s=0), scale parameter ![\\sigma](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=%5Csigma&bg=ffffff&fg=000000&s=0), and ![\\nu](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=%5Cnu&bg=ffffff&fg=000000&s=0) degrees of freedom. 

We specify and build our state space model below, using ![t=10](https://web.archive.org/web/20250518105335im_/https://s0.wp.com/latex.php?latex=t%3D10&bg=ffffff&fg=000000&s=0) time points:
    
    
    ## load the nimble library and set seed
    library('nimble')
    set.seed(1)
    
    ## define the model
    stateSpaceCode <- nimbleCode({
        a ~ dunif(-0.9999, 0.9999)
        b ~ dnorm(0, sd = 1000)
        sigPN ~ dunif(1e-04, 1)
        sigOE ~ dunif(1e-04, 1)
        x[1] ~ dnorm(b/(1 - a), sd = sigPN/sqrt((1-a*a)))
        y[1] ~ dt(mu = x[1], sigma = sigOE, df = 5)
        for (i in 2:t) {
            x[i] ~ dnorm(a * x[i - 1] + b, sd = sigPN)
            y[i] ~ dt(mu = x[i], sigma = sigOE, df = 5)
        }
    })
    
    ## define data, constants, and initial values  
    data <- list(
        y = c(0.213, 1.025, 0.314, 0.521, 0.895, 1.74, 0.078, 0.474, 0.656, 0.802)
    )
    constants <- list(
        t = 10
    )
    inits <- list(
        a = 0,
        b = .5,
        sigPN = .1,
        sigOE = .05
    )
    
    ## build the model
    stateSpaceModel <- nimbleModel(stateSpaceCode,
                                  data = data,
                                  constants = constants,
                                  inits = inits,
                                  check = FALSE)
    
    
    
    ## defining model...
    
    
    
    ## building model...
    
    
    
    ## setting data and initial values...
    
    
    
    ## running calculate on model (any error reports that follow may simply
    ## reflect missing values in model variables) ...
    
    
    
    ## 
    
    
    
    ## checking model sizes and dimensions...
    
    
    
    ## note that missing values (NAs) or non-finite values were found in model
    ## variables: x, lifted_a_times_x_oBi_minus_1_cB_plus_b. This is not an error,
    ## but some or all variables may need to be initialized for certain algorithms
    ## to operate properly.
    
    
    
    ## 
    
    
    
    ## model building finished.
    

# Construct and run a bootstrap filter

We next construct a bootstrap filter to conduct inference on the latent states of our state space model. Note that the bootstrap filter, along with the auxiliary particle filter and the ensemble Kalman filter, treat the top-level parameters `a, b, sigPN`, and `sigOE` as fixed. Therefore, the bootstrap filter below will proceed as though `a = 0, b = .5, sigPN = .1`, and `sigOE = .05`, which are the initial values that were assigned to the top-level parameters.

The bootstrap filter takes as arguments the name of the model and the name of the latent state variable within the model. The filter can also take a control list that can be used to fine-tune the algorithm’s configuration.
    
    
    ## build bootstrap filter and compile model and filter
    bootstrapFilter <- buildBootstrapFilter(stateSpaceModel, nodes = 'x')
    compiledList <- compileNimble(stateSpaceModel, bootstrapFilter)
    
    
    
    ## compiling... this may take a minute. Use 'showCompilerOutput = TRUE' to see C++ compiler details.
    
    
    
    ## compilation finished.
    
    
    
    ## run compiled filter with 10,000 particles.  
    ## note that the bootstrap filter returns an estimate of the log-likelihood of the model.
    compiledList$bootstrapFilter$run(10000)
    
    
    
    ## [1] -28.13009
    

Particle filtering algorithms in `nimble` store weighted samples of the filtering distribution of the latent states in the `mvSamples` modelValues object. Equally weighted samples are stored in the `mvEWSamples` object. By default, `nimble` only stores samples from the final time point.
    
    
    ## extract equally weighted posterior samples of x[10]  and create a histogram
    posteriorSamples <- as.matrix(compiledList$bootstrapFilter$mvEWSamples)
    hist(posteriorSamples)
    

![plot of chunk plot-bootstrap](https://web.archive.org/web/20250518105335im_/https://r-nimble.org/wp-content/uploads/2017/01/plot-bootstrap-1.png)

The auxiliary particle filter and ensemble Kalman filter can be constructed and run in the same manner as the bootstrap filter.

# Conduct inference on top-level parameters using particle MCMC

Particle MCMC can be used to conduct inference on the posterior distribution of both the latent states and any top-level parameters of interest in a state space model. The particle marginal Metropolis-Hastings sampler can be specified to jointly sample the `a, b, sigPN`, and `sigOE` top level parameters within `nimble`‘s MCMC framework as follows:
    
    
    ## create MCMC specification for the state space model
    stateSpaceMCMCconf <- configureMCMC(stateSpaceModel, nodes = NULL)
    
    ## add a block pMCMC sampler for a, b, sigPN, and sigOE 
    stateSpaceMCMCconf$addSampler(target = c('a', 'b', 'sigPN', 'sigOE'),
                                  type = 'RW_PF_block', control = list(latents = 'x'))
    
    ## build and compile pMCMC sampler
    stateSpaceMCMC <- buildMCMC(stateSpaceMCMCconf)
    compiledList <- compileNimble(stateSpaceModel, stateSpaceMCMC, resetFunctions = TRUE)
    
    
    
    ## compiling... this may take a minute. Use 'showCompilerOutput = TRUE' to see C++ compiler details.
    
    
    
    ## compilation finished.
    
    
    
    ## run compiled sampler for 5000 iterations
    compiledList$stateSpaceMCMC$run(5000)
    
    
    
    ## |-------------|-------------|-------------|-------------|
    ## |-------------------------------------------------------|
    
    
    
    ## NULL
    
    
    
    ## create trace plots for each parameter
    library('coda')
    
    
    
    par(mfrow = c(2,2))
    posteriorSamps <- as.mcmc(as.matrix(compiledList$stateSpaceMCMC$mvSamples))
    traceplot(posteriorSamps[,'a'], ylab = 'a')
    traceplot(posteriorSamps[,'b'], ylab = 'b')
    traceplot(posteriorSamps[,'sigPN'], ylab = 'sigPN')
    traceplot(posteriorSamps[,'sigOE'], ylab = 'sigOE')
    

![plot of chunk run-PMCMC](https://web.archive.org/web/20250518105335im_/https://r-nimble.org/wp-content/uploads/2017/01/run-PMCMC-1.png)

The above `RW_PF_block` sampler uses a multivariate normal proposal distribution to sample vectors of top-level parameters. To sample a scalar top-level parameter, use the `RW_PF` sampler instead.